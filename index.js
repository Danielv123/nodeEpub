var epub = require('quick-epub');
var needle = require("needle");
var cheerio = require("cheerio")
var express = require("express");
// Required for express post requests
var bodyParser = require("body-parser");
var app = express();

app.use(express.static('books'));
app.use(bodyParser.json({limit: '500mb'}));
app.use(bodyParser.urlencoded({limit: '500mb', extended: true}));

app.post("/epubify", function(req, res) {
	res.header("Access-Control-Allow-Origin", "*");
	res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
	// console.log(req.body)
	// ensure validity of requests
	if (!req.body.contents) {
		res.send("failure");
		return false;
	}
	if (!req.body.title) {
		res.send("failure");
		return false;
	}
	console.log("Creating book with title: " + req.body.title);
	if (!req.body.bookID) req.body.bookID = Math.floor(Math.random()*1000000);
	if (!req.body.data) req.body.data = {}
	
	// book generation methods
	if(req.body.ebookMethod == "links") {
		// POST {data:{}, title:"", contents:[{title, url, dataSelector}, {title, url, dataSelector}, ..], bookID}
		// RETURNS "success" or "failure"
		// ON "success", send GET to [ip]/[bookID].epub
		var data = {
			language: req.body.data.language || 'en',
			title: req.body.title,
			author: req.body.data.author || ['unknown'],
			publisher: req.body.data.publisher || 'Fanfiction/wattpad via Danielv123',
			description: req.body.data.description || 'Ebook generated by Danielv123',
			contents: [],
			// dates: {
				// published: req.body.data.publishedDate || new Date().toISOString().split('.')[0]+ 'Z',
				// modified: req.body.data.modifiedDate || new Date().toISOString().split('.')[0]+ 'Z'
			// },
			appendChapterTitles: true,
			output: "books/" + req.body.bookID + ".epub"
		};
		// download books from pages
		let chapters = req.body.contents.length;
		let downloadedChapters = 0;
		for (let ii = 0; ii < req.body.contents.length; ii++) {
			let chapter = req.body.contents[ii];
			needle.get(chapter.url, {
				headers: {
					'Accept-Encoding': 'gzip', // fanfiction.net now defaults to Deflate, which has too many terrible implementations.
				}
			}, function(error, response) {
				console.log(error)
				// console.log(response)
				if(!error && response.statusCode == 200) {
					var $ = cheerio.load(response.body);
					console.log("Downloaded chapter " + (ii + 1) + `, got ${downloadedChapters} out of ${chapters}`);
					data.contents[ii] = {};
					if(!req.body.contents[ii].dataSelector) {
						data.contents[ii].content = response.body;
					} else {
						data.contents[ii].content = $(chapter.dataSelector).html();
					}
					data.contents[ii].title = chapter.title || "Chapter " + (ii + 1);
					
					// if we have them all, package ebook
					if(++downloadedChapters == chapters) {
						console.log("All chapters downloaded")
						// patch up for later versions
						data.chapters = data.contents
						delete data.contents
						console.log(data)
						epub.createFile(data).then(function(){
							console.log('book done: ' + req.body.bookID);
							res.send("success");
						}).catch(function(error){
							console.error(error);
							res.send("failure");
						});
					}
				}
			});
		}
		
	} else {
		// Default to use old method. This to ensure backwards compat.
		var data = {
			title: req.body.title,
			author: ['unknown'],
			description: 'Ebook generated by Danielv123',
			contents: req.body.contents,
			dates: {
				published: new Date().toISOString().split('.')[0]+ 'Z',
				modified: new Date().toISOString().split('.')[0]+ 'Z'
			},
			appendChapterTitles: true,
			output: "books/" + req.body.bookID + ".epub"
		};
		epub.createFile(data).then(function(){
			console.log('book done: ' + req.body.bookID);
			res.send("success");
		}).catch(function(error){
			console.error(error);
			res.send("failure");
		});
	}
	// res.send("success");
});


var server = app.listen(80, function () {
	console.log("Listening on port %s...", server.address().port);
});
